# CPU 스케줄링

- CPU는 프로그램의 기계어 명렁을 실제로 수행하는 컴퓨터 내의 중앙 처리장치
- 프로그램이 시작되어 메모리에 올라가면, **프로그램 카운터(Program Counter)**라는 이름의 레지스터가 현재 CPU에서 수행할 코드의 메모리 주소값을 가지고 CPU는 프로그램 카운터가 가리키는 주소의 기계어 명령을 하나씩 수행
- CPU는 일반적인 시스템내에 하나밖에 없으므로 여러 프로그램이 동시에 수행되는 시분할 환경에서 CPU를 매우 효율적으로 관리되어야 합니다.

### 1. **I/O 바운드 프로세스 와 CPU 바운드 프로세스**

- 사용자 프로그램이 수행되는 과정을 보면 CPU 작업과 I/O 작업의 반복됩니다.
- CPU 작업(CPU Burst)
  - 레지스터 간의 연산(Add, Load, Store)등은 사용자 프로그램이 직접 CPU를 가지고 수행하는 비교적 빠른 명령입니다.

- I/O 작업(I/O Burst)
  - 수행 도중 I/O 요청을 하게되면 CPU의 제어권이 운영 체제 커널로 넘어갈 뿐만 아니라 상대적으로 매우 느린 입출력 장치의 접근을 필요로 합니다. 
- 각 프로그램마다 CPU 버스트와 I/O 버스트가 차지하는 비율이 균일하지는 않습니다. 
- 어떤 프로세스는 I/O 버스트가 빈번하고 어떤 프로세스는 CPU 버스트가 매우 길게 나타납니다. 
- 이와 같은 기준에서 프로세스를 크게 I/O 바운드 프로세스, CPU 바운드 프로세스로 나누어 볼 수 있습니다.
  - I/O 바운드 프로세스
    - I/O 요청이 빈번해 CPU 버스트가 짧게 나타나는 프로세스
    - 주로 사용자로부터 인터액션을 계속 받아가며 프로그램을 수행하는 대화형 프로그램
  - CPU 바운드 프로세스
    - I/O 작업을 거의 수행하지 않아 CPU 버스트가 길게 나타나는 프로세스 
    - 프로세스 수행의 상당 시간을 입출력 작업 없이 CPU 작업에 소모하는 계산 위주의 프로그램

### 2. CPU 스케줄링의 필요성

- CPU 스케줄링은 이와 같이 CPU를 사용하는 패턴이 상이한 여러 프로그램이 동일한 시스템 내부에서 함께 실행되기 때문에 필요한 것입니다. 
- 만약 프로세스의 CPU 버스트가 모두 균일한 경우에는 CPU 스케줄링이 큰 의미가 없지만, 우리가 사용하는 시분할 시스템에서는 이와 같이 CPU 버스트가 균일하지 않은 다양한 프로그램이 공존하므로 효율적인 CPU 스케줄링 기법이 반드시 필요합니다.
- 대부분의 프로세스들의 CPU 버스트를 분석해 보면 대부분 짧은 CPU 버스트를 가지며 극히 일부분만 긴 CPU 버스트를 가집니다. 
- 이는 다시 말해 CPU를 한 번에 오래 사용하기 보다는 잠깐 사용하고 I/O 작업을 수행하는 프로세스들이 많다는 뜻입니다.
- 따라서 CPU 스케줄링을 할 때는 CPU 버스트가 짧은 프로세스들에게 우선적으로 CPU를 사용할 수 있도록 하는 스케줄링이 필요합니다. 이는 바꾸어 말하면 스케줄링 시 I/O 바운드 프로세스에게 우선순위를 높여주는 것이 바람직하다는 의미가 됩니다.



### 3. **디스패처(dispatcher)**

- CPU 스케줄링 알고리즘에 의해 어떤 프로세스에게 CPU를 할당해야 할지를 결정하고 나면 선택된 프로세스에게 실제로 CPU를 이양하는 작업이 필요한데, 이와 같이 새롭게 선택된 프로세스가 CPU를 할당받고 작업을 수행할 수 있도록 환경을 설정하는 커널 모듈을 **디스패처(dispatcher)**라고 합니다.
- 디스패처는 현재 수행중이던 프로세스의 문맥(Context)를 그 프로세스의 PCB에 저장하고 새롭게 선택된 프로세스의 문맥을 PCB로부터 복원한 후 그 프로세스에게 CPU를 넘기는 과정을 수행합니다.
- 디스패처가 하나의 프로세스를 정지시키고 다른 프로세스에게 CPU를 전달하기 까지 걸리는 시간을 우리는 디스패치 지연시간(dispatcher latency)이라고 부릅니다. 
  - 디스패치 지연시간의 대부분은 문맥교환 오버헤드에 해당합니다.



### 4. **CPU 스케줄링 알고리즘**

- 단기스케줄러에서 사용하며 준비 상태의 프로세스(Ready Queue)중에서 어떤 프로세스에게 CPU를 할당할지를 결정합니다.
- CPU스케줄링 방식에는 비선점형 방식과 선점형 방식이 존재
  - 비선점형
    - CPU를 획득한 프로세스가 스스로 CPU를 반납하기 전까지 CPU를 빼앗기지 않는 방법
  - 선점형
    - 프로세스가 CPU를 계속 사용하기를 원하더라도 강제로 빼앗을 수 있는 스케줄링 방법
    - CPU를 빼앗는 방법으로는 할당시간을 부여한 후 타이머 인터럽트를 발생시키는 방법

- FCFS( First Come First Served ) - 비선점

  - 준비큐에 도착한 시간 순서대로 CPU를 할당하는 방식입니다.

  - CPU를 먼저 요청한 프로세스에게 CPU를 먼저 할당하고, 그 프로세스가 자발적으로 CPU를 반납할 때까지 CPU를 선점하지 않습니다.

  - 먼저 온 요청을 먼저 처리하기 때문에 합리적인 스케줄링 방식인 것 같지만 경우에 따라 비효율적일 수도 있습니다. 

  - CPU 버스트가 긴 A프로세스가 먼저 도착하고 그 후에 CPU 버스트가 짧은 B프로세스가 도착하게 되면 B프로세스는 CPU를 잠깐 사용하고 I/O 작업을 하면 되는데 A프로세스 때문에 준비 큐에서 오래 기다려야 하므로 평균 대기시간이 길어지게 됩니다.

    - 즉, CPU 버스트가 긴 프로세스가 먼저 도착할 경우 평균 대기시간이 길어지는 반면, CPU 버스트가 짧은 프로세스가 먼저 도착하게 되면 평균 대기 시간은 짧아지게 됩니다.

  - 예시

    - | 프로세스 | CPU burst 시간 |
      | -------- | -------------- |
      | P1       | 12             |
      | P2       | 3              |
      | P3       | 3              |

    - P1 : 대기시간 0s

    - P2 : 대기시간 12s

    - P3 : 대기시간 15s

    - 평균 대기시간 (0+12+15) / 3 = 9s

    - | 프로세스 | CPU burst 시간 |
      | -------- | -------------- |
      | P2       | 3              |
      | P3       | 3              |
      | P1       | 12             |

    - P2 : 대기시간 0s

    - P3 : 대기시간 3s

    - P1 : 대기시간 6s

    - 평균 대기시간 : (0+3+6) / 3 = 3s

    - 결론

      - 두 가지의 경우를 비교했을 때, CPU버스트 시간이 짧은 프로세스가 먼저 도착한 경우 평균 대기시간이 크게 줄어든 것을 확인할 수 있습니다. 
      - 첫번째 경우처럼 CPU 버스트가 짧은 프로세스가 CPU 버스트가 긴 프로세스보다 나중에 도착해 오랜 시간을 기다려야 하는 현상을 **콘보이 현상(Convoy Effect)**라고 합니다. 

- SJF( Shortest Job First ) - 비선점 / 선점

  - CPU 버스트가 가장 짧은 프로세스에게 제일 먼저 CPU를 할당하는 방식입니다.

  - 이와 같은 방식은 CPU 버스트가 짧은 프로세스가 CPU를 먼저 사용하고 준비 큐를 빠져나가기 때문에 평균 대기시간을 가장 짧게 하는 최적의 알고리즘으로 알려져 있습니다.

  - 비선점형

    - 일단 CPU를 획득하면 그 프로세스가 CPU를 자진 반납하기 전까지 CPU를 선점당하지 않는 방식입니다.

  - 선점형

    - 현재 CPU에서 실행중인 프로세스의 남은 CPU 버스트 시간보다 더 짧은 CPU 버스트시간을 가지는 프로세스가 도착하면 CPU를 빼앗게 됩니다. 
    - 일반적인 시분할 환경에서는 중간중간에 새로운 프로세스가 도착하는 경우가 발생하므로 선점형 방식이 평균 대기시간을 가장 많이 줄일 수 있는 방식이 됩니다. 
    - SJF를 선점형 구현 방식을 SRTF(Shortest Remaining Time First)라고 합니다. 

  - SFJ 비선점형 스케줄링

  - | 프로세스 | 도착시간 | CPU burst 시간 |
    | -------- | -------- | -------------- |
    | P1       | 0        | 14             |
    | P2       | 4        | 8              |
    | P3       | 8        | 2              |
    | P4       | 10       | 8              |

    - P1 : 0s에 도착했고 준비큐가 비었기 때문에 바로 CPU 사용 = 대기시간 0s
    - P3 : 14s에 P1이 끝났고 준비큐에는 [P2, P3, P4]가 존재 => burst가 가장 짧은 P3 선택
      - 8s에 도착했고 14s에 CPU를 할당 => 대기시간 6s
    - P2 : 16s에 P3이 끝남 => 준비큐에는 [P2, P4]가 존재 => 먼저 도착한 P2 선택
      - 4s에 도착했고 16s에 CPU를 할당 => 대기시간 12s
    - P4 : 24s에 P2가 끝남 => 준비큐에는 [P4]가 존재
      - 10s에 도착했고 24s에 CPU를 할당 => 대기시간 14s
    - 평균 대기시간 (0+6+12+14) / 4 = 8s

  - SJF 선점형 스케줄링

    - SJF선점형 방식은 프로세스가 새롭게 도착하거나 작업이 끝났을 때마다 CPU 버스트 시간을 비교

  - | 프로세스 | 도착시간 | CPU burst 시간 |
    | -------- | -------- | -------------- |
    | P1       | 0        | 14             |
    | P2       | 4        | 8              |
    | P3       | 8        | 2              |
    | P4       | 10       | 8              |

    - 0s => P1만 도착 및 CPU 사용
    - 4s => P1이 CPU를 4s 동안 사용하다 4s 시점에 P2가 준비큐에 도착, P2의 CPU Burst 시간이 P1보다 짧기 때문에 P2에게 CPU를 선점당합니다.
    - 8s => P2가 CPU를 4s 동안 사용하다 8s 시점에 P3가 준비큐에 도착, P3의 CPU Burst 시간이 P2보다 짧기 때문에 P3에게 CPU를 선점당합니다.
    - 10s => P3가 10s에 CPU를 모두 사용, 때문에 다음 프로세스를 선택 => 현재 P2의 CPU Burst 시간이 가장 짧기 때문에 P2에게 CPU 할당
      - 여기서, P2는 8s, P3에게 CPU를 선점 당했다 10s 에 다시 CPU를 할당 받았기 때문에 P2의 총 대기시간에 2s를 더함
    - 14s => P2가 14s CPU를 모두 사용 => 다음 프로세스를 선택 => 현재 P4의 CPU Burst 시간이 가장 짧기 때문에 P4에게 CPU를 할당
      - 여기서, P4는 10s 에 도착해서 14s 에 처음 CPU를 할당 받았기 때문에 P4의 총 대기시간에 4s를 더함
    - 22s => P4가 22s에 CPU를 모두 사용 => 다음 프로세스를 선택 => 현재 P1만 남은 CPU Burst시간이 있기 때문에 P1에세 CPU를 할당.
      - 여기서, P1은 4s 에 P2에게 CPU를 선점 당했다 22s 에 다시 CPU를 할당 받았기 때문에 총 대기시간에 18을 더함
    - **평균 대기시간** : P1 + P2 + P3 + P4 = (18 + 2 + 0 + 4) / 4 = 6

  - SJF는 구현에서 현실적으로 어려운 부분은 프로세스의 CPU 버스트 시간을 미리 알 수 없다는 점입니다. 

  - 그래서 예측을 통해 CPU Burst 시간을 구한 후 예측치가 가장 짧은 프로세스에게 CPU를 할당하게 됩니다. 

  - 또한 계속 CPU Burst가 짧은 프로스세에게만 CPU를 할당할 경우 CPU 버스트가 긴 프로세스는 준비 큐에서 무한정 기다려야 하는 문제가 발생할 수 있는데, 이런 현상을 **기아현상**이라고 합니다.

- 우선순위 스케줄링 - 선점 / 비선점
  - 준비 큐에서 기다리는 프로세스들 중에서 우선순위가 가장 높은 프로세스에게 제일 먼저 CPU를 할당하는 방식을 말합니다. 
  - 이때 우선순위는 우선순위 값을 통해 표시하며 우선순위값이 작을수록 높은 우선순위를 가지는 것으로 가정합니다.
  - 우선순위를 결정하는 방식에는 여러가지가 있는데, CPU 버스트시간을 우선순위 값으로 정의하면 우선순위 스케줄링은 SJF 알고리즘과 동일한 의미를 가지게 됩니다. 
  - 시스템과 관련된 중요한 작업을 수행하는 프로세스의 우선순위를 높게 부여하면 이러한 프로세스가 CPU를 빨리 할당받을 수 있습니다.
  - 선점형 스케줄링(Preemptive) 방식
    - 더 높은 우선순위의 프로세스가 도착하면 실행중인 프로세스를 멈추고 CPU 를 선점한다.
  - 비선점형 스케줄링(Non-Preemptive) 방식
    - 더 높은 우선순위의 프로세스가 도착하면 Ready Queue 의 Head 에 넣는다.
  - 노화기법 ( aging )
    - 우선순위 스케줄링 방식에서의 문제점 중 하나는 **기아 현상**이 발생할 수 있다는 점인데, 이는 노화기법으로 해결할 수 있습니다. 
    - 기다리는 시간이 길어지면 우선순위를 조금씩 높여 언젠가는 가장 높은 우선순위를 가지는 방법입니다.
- 라운드 로빈 스케줄링 - 선점
  - 지금 까지 소개한 스케줄링 방식과 달리 시분할 시스템의 성질을 가장 잘 활용한 새로운 스케줄링 방식으로 **각 프로세스가 CPU를 연속적으로 사용할 수 있는 시간을 특정 시간으로 제한**하여 이 시간이 경과하면 프로세스로부터 CPU를 회수해 준비 큐에 있는 다른 프로세스에게 CPU를 할당 합니다.
    - 각 프로세스는 동일한 크기의 할당 시간(time quantum)을 갖게 된다.
    - CPU 사용시간이 랜덤한 프로세스들이 섞여있을 경우에 효율적
  - 여기서 각 프로세스마다 한 번에 CPU를 연속으로 사용할 수 있는 최대 시간을 **할당 시간**(Time Quantum)이라고 부릅니다. 
  - **할당 시간이 너무 길면 라운드 로빈 스케줄링은 FCFS와 같게 되며 너무 짧은 경우 문맥 교환의 오버헤드가 커지게 됩니다.**
    - 적당한 `time quantum`을 설정하는 것이 중요하다.
  - 라운드 로빈 스케줄링은 여러 종류의 이질적인 프로세스가 같이 실행되는 환경에서 효과적입니다. 
    - 예를 들어 n개의 프로세스가 준비 큐에 있고 할당 시간이 q라고 할 때, 모든 프로세스는적어도 (n-1)q 시간 이내에 한번은 CPU를 할당받을 수 있게 됩니다. 
    - `Response time`이 빨라집니다.
  - 할당 시간이 만료되어 CPU를 회수하는 방법으로는 타이머 인터럽트를 사용하게 됩니다. 만약 CPU Burst 시간이 할당 시간보다 짧으면 CPU를 자신의 버스트 만큼 사용한 후 스스로 반납하게 됩니다. 
  - 라운드 로빈 스케줄링의 목적은 CPU 버스트 시간이 짧은 프로세스가 빨리 CPU를 얻을 수 있도록 하는 동시에, CPU 버스트 시간이 긴 프로세스가 불이익을 당하지 않도록 하는 것이며 프로세스의 대기시간 또한 자신이 사용하는 CPU 버스트 시간에 비례해 증가하므로 공정하다 볼 수 있습니다.



## 참고 링크

- https://kosaf04pyh.tistory.com/194?category=1032510
- https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/OS#cpu-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC